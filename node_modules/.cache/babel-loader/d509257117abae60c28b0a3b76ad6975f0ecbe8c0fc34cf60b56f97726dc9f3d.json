{"ast":null,"code":"import _classCallCheck from \"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as utils from './utils.js';\nimport { Base } from './Base.js';\nexport var Pointer = /*#__PURE__*/function (_Base) {\n  _inherits(Pointer, _Base);\n  var _super = _createSuper(Pointer);\n  function Pointer(offsetType, type) {\n    var _this;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Pointer);\n    _this = _super.call(this);\n    _this.offsetType = offsetType;\n    _this.type = type;\n    _this.options = options;\n    if (_this.type === 'void') {\n      _this.type = null;\n    }\n    if (_this.options.type == null) {\n      _this.options.type = 'local';\n    }\n    if (_this.options.allowNull == null) {\n      _this.options.allowNull = true;\n    }\n    if (_this.options.nullValue == null) {\n      _this.options.nullValue = 0;\n    }\n    if (_this.options.lazy == null) {\n      _this.options.lazy = false;\n    }\n    if (_this.options.relativeTo) {\n      if (typeof _this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      _this.relativeToGetter = options.relativeTo;\n    }\n    return _this;\n  }\n  _createClass(Pointer, [{\n    key: \"decode\",\n    value: function decode(stream, ctx) {\n      var _this2 = this;\n      var offset = this.offsetType.decode(stream, ctx);\n\n      // handle NULL pointers\n      if (offset === this.options.nullValue && this.options.allowNull) {\n        return null;\n      }\n      var relative;\n      switch (this.options.type) {\n        case 'local':\n          relative = ctx._startOffset;\n          break;\n        case 'immediate':\n          relative = stream.pos - this.offsetType.size();\n          break;\n        case 'parent':\n          relative = ctx.parent._startOffset;\n          break;\n        default:\n          var c = ctx;\n          while (c.parent) {\n            c = c.parent;\n          }\n          relative = c._startOffset || 0;\n      }\n      if (this.options.relativeTo) {\n        relative += this.relativeToGetter(ctx);\n      }\n      var ptr = offset + relative;\n      if (this.type != null) {\n        var val = null;\n        var decodeValue = function decodeValue() {\n          if (val != null) {\n            return val;\n          }\n          var pos = stream.pos;\n          stream.pos = ptr;\n          val = _this2.type.decode(stream, ctx);\n          stream.pos = pos;\n          return val;\n        };\n\n        // If this is a lazy pointer, define a getter to decode only when needed.\n        // This obviously only works when the pointer is contained by a Struct.\n        if (this.options.lazy) {\n          return new utils.PropertyDescriptor({\n            get: decodeValue\n          });\n        }\n        return decodeValue();\n      } else {\n        return ptr;\n      }\n    }\n  }, {\n    key: \"size\",\n    value: function size(val, ctx) {\n      var parent = ctx;\n      switch (this.options.type) {\n        case 'local':\n        case 'immediate':\n          break;\n        case 'parent':\n          ctx = ctx.parent;\n          break;\n        default:\n          // global\n          while (ctx.parent) {\n            ctx = ctx.parent;\n          }\n      }\n      var type = this.type;\n      if (type == null) {\n        if (!(val instanceof VoidPointer)) {\n          throw new Error(\"Must be a VoidPointer\");\n        }\n        var _val = val;\n        type = _val.type;\n        val = val.value;\n      }\n      if (val && ctx) {\n        // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n        var size = type.size(val, parent);\n        ctx.pointerSize += size;\n      }\n      return this.offsetType.size();\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(stream, val, ctx) {\n      var relative;\n      var parent = ctx;\n      if (val == null) {\n        this.offsetType.encode(stream, this.options.nullValue);\n        return;\n      }\n      switch (this.options.type) {\n        case 'local':\n          relative = ctx.startOffset;\n          break;\n        case 'immediate':\n          relative = stream.pos + this.offsetType.size(val, parent);\n          break;\n        case 'parent':\n          ctx = ctx.parent;\n          relative = ctx.startOffset;\n          break;\n        default:\n          // global\n          relative = 0;\n          while (ctx.parent) {\n            ctx = ctx.parent;\n          }\n      }\n      if (this.options.relativeTo) {\n        relative += this.relativeToGetter(parent.val);\n      }\n      this.offsetType.encode(stream, ctx.pointerOffset - relative);\n      var type = this.type;\n      if (type == null) {\n        if (!(val instanceof VoidPointer)) {\n          throw new Error(\"Must be a VoidPointer\");\n        }\n        var _val2 = val;\n        type = _val2.type;\n        val = val.value;\n      }\n      ctx.pointers.push({\n        type: type,\n        val: val,\n        parent: parent\n      });\n      return ctx.pointerOffset += type.size(val, parent);\n    }\n  }]);\n  return Pointer;\n}(Base);\n\n// A pointer whose type is determined at decode time\nexport var VoidPointer = /*#__PURE__*/_createClass(function VoidPointer(type, value) {\n  _classCallCheck(this, VoidPointer);\n  this.type = type;\n  this.value = value;\n});","map":{"version":3,"names":["utils","Base","Pointer","_Base","_inherits","_super","_createSuper","offsetType","type","_this","options","arguments","length","undefined","_classCallCheck","call","allowNull","nullValue","lazy","relativeTo","Error","relativeToGetter","_createClass","key","value","decode","stream","ctx","_this2","offset","relative","_startOffset","pos","size","parent","c","ptr","val","decodeValue","PropertyDescriptor","get","VoidPointer","_val","pointerSize","encode","startOffset","pointerOffset","_val2","pointers","push"],"sources":["/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/restructure/src/Pointer.js"],"sourcesContent":["import * as utils from './utils.js';\nimport {Base} from './Base.js';\n\nexport class Pointer extends Base {\n  constructor(offsetType, type, options = {}) {\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n    if (this.type === 'void') { this.type = null; }\n    if (this.options.type == null) { this.options.type = 'local'; }\n    if (this.options.allowNull == null) { this.options.allowNull = true; }\n    if (this.options.nullValue == null) { this.options.nullValue = 0; }\n    if (this.options.lazy == null) { this.options.lazy = false; }\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx);\n\n    // handle NULL pointers\n    if ((offset === this.options.nullValue) && this.options.allowNull) {\n      return null;\n    }\n\n    let relative;\n    switch (this.options.type) {\n      case 'local':     relative = ctx._startOffset; break;\n      case 'immediate': relative = stream.pos - this.offsetType.size(); break;\n      case 'parent':    relative = ctx.parent._startOffset; break;\n      default:\n        var c = ctx;\n        while (c.parent) {\n          c = c.parent;\n        }\n\n        relative = c._startOffset || 0;\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n\n    const ptr = offset + relative;\n\n    if (this.type != null) {\n      let val = null;\n      const decodeValue = () => {\n        if (val != null) { return val; }\n\n        const { pos } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      };\n\n      // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue});\n      }\n\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n\n  size(val, ctx) {\n    const parent = ctx;\n    switch (this.options.type) {\n      case 'local': case 'immediate':\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n      default: // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n\n    return this.offsetType.size();\n  }\n\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n    if ((val == null)) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n      default: // global\n        relative = 0;\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n}\n\n// A pointer whose type is determined at decode time\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}