{"ast":null,"code":"import _classCallCheck from \"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Struct } from './Struct.js';\nvar getPath = function getPath(object, pathArray) {\n  return pathArray.reduce(function (prevObj, key) {\n    return prevObj && prevObj[key];\n  }, object);\n};\nexport var VersionedStruct = /*#__PURE__*/function (_Struct) {\n  _inherits(VersionedStruct, _Struct);\n  var _super = _createSuper(VersionedStruct);\n  function VersionedStruct(type) {\n    var _this;\n    var versions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, VersionedStruct);\n    _this = _super.call(this);\n    _this.type = type;\n    _this.versions = versions;\n    if (typeof type === 'string') {\n      _this.versionPath = type.split('.');\n    }\n    return _this;\n  }\n  _createClass(VersionedStruct, [{\n    key: \"decode\",\n    value: function decode(stream, parent) {\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var res = this._setup(stream, parent, length);\n      if (typeof this.type === 'string') {\n        res.version = getPath(parent, this.versionPath);\n      } else {\n        res.version = this.type.decode(stream);\n      }\n      if (this.versions.header) {\n        this._parseFields(stream, res, this.versions.header);\n      }\n      var fields = this.versions[res.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \".concat(res.version));\n      }\n      if (fields instanceof VersionedStruct) {\n        return fields.decode(stream, parent);\n      }\n      this._parseFields(stream, res, fields);\n      if (this.process != null) {\n        this.process.call(res, stream);\n      }\n      return res;\n    }\n  }, {\n    key: \"size\",\n    value: function size(val, parent) {\n      var includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var key, type;\n      if (!val) {\n        throw new Error('Not a fixed size');\n      }\n      if (this.preEncode != null) {\n        this.preEncode.call(val);\n      }\n      var ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      var size = 0;\n      if (typeof this.type !== 'string') {\n        size += this.type.size(val.version, ctx);\n      }\n      if (this.versions.header) {\n        for (key in this.versions.header) {\n          type = this.versions.header[key];\n          if (type.size != null) {\n            size += type.size(val[key], ctx);\n          }\n        }\n      }\n      var fields = this.versions[val.version];\n      if (fields == null) {\n        throw new Error(\"Unknown version \".concat(val.version));\n      }\n      for (key in fields) {\n        type = fields[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n      return size;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(stream, val, parent) {\n      var key, type;\n      if (this.preEncode != null) {\n        this.preEncode.call(val, stream);\n      }\n      var ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n      if (typeof this.type !== 'string') {\n        this.type.encode(stream, val.version);\n      }\n      if (this.versions.header) {\n        for (key in this.versions.header) {\n          type = this.versions.header[key];\n          if (type.encode != null) {\n            type.encode(stream, val[key], ctx);\n          }\n        }\n      }\n      var fields = this.versions[val.version];\n      for (key in fields) {\n        type = fields[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n      var i = 0;\n      while (i < ctx.pointers.length) {\n        var ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    }\n  }]);\n  return VersionedStruct;\n}(Struct);","map":{"version":3,"names":["Struct","getPath","object","pathArray","reduce","prevObj","key","VersionedStruct","_Struct","_inherits","_super","_createSuper","type","_this","versions","arguments","length","undefined","_classCallCheck","call","versionPath","split","_createClass","value","decode","stream","parent","res","_setup","version","header","_parseFields","fields","Error","concat","process","size","val","includePointers","preEncode","ctx","pointerSize","encode","pointers","startOffset","pos","pointerOffset","i","ptr"],"sources":["/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/restructure/src/VersionedStruct.js"],"sourcesContent":["import {Struct} from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type, versions = {}) {\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent, length = 0) {\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n\n  size(val, parent, includePointers = true) {\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}