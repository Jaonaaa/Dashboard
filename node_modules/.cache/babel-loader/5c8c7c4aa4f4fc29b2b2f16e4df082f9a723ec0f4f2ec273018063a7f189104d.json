{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _defineProperty = require(\"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _regeneratorRuntime = require(\"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar INITIAL_STATE = 1;\nvar FAIL_STATE = 0;\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\nvar StateMachine = /*#__PURE__*/function () {\n  function StateMachine(dfa) {\n    _classCallCheck(this, StateMachine);\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n  _createClass(StateMachine, [{\n    key: \"match\",\n    value: function match(str) {\n      var self = this;\n      return _defineProperty({}, Symbol.iterator, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var state, startRun, lastAccepting, lastState, p, c;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              state = INITIAL_STATE;\n              startRun = null;\n              lastAccepting = null;\n              lastState = null;\n              p = 0;\n            case 5:\n              if (!(p < str.length)) {\n                _context.next = 21;\n                break;\n              }\n              c = str[p];\n              lastState = state;\n              state = self.stateTable[state][c];\n              if (!(state === FAIL_STATE)) {\n                _context.next = 15;\n                break;\n              }\n              if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                _context.next = 13;\n                break;\n              }\n              _context.next = 13;\n              return [startRun, lastAccepting, self.tags[lastState]];\n            case 13:\n              // reset the state as if we started over from the initial state\n\n              state = self.stateTable[INITIAL_STATE][c];\n              startRun = null;\n            case 15:\n              // start a run if not in the failure state\n\n              if (state !== FAIL_STATE && startRun == null) {\n                startRun = p;\n              } // if accepting, mark the potential match end\n\n              if (self.accepting[state]) {\n                lastAccepting = p;\n              } // reset the state to the initial state if we get into the failure state\n\n              if (state === FAIL_STATE) {\n                state = INITIAL_STATE;\n              }\n            case 18:\n              p++;\n              _context.next = 5;\n              break;\n            case 21:\n              if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                _context.next = 24;\n                break;\n              }\n              _context.next = 24;\n              return [startRun, lastAccepting, self.tags[state]];\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n    }\n    /**\n     * For each match over the input sequence, action functions matching\n     * the tag definitions in the input pattern are called with the startIndex,\n     * endIndex, and sub-match sequence.\n     */\n  }, {\n    key: \"apply\",\n    value: function apply(str, actions) {\n      var _iterator = _createForOfIteratorHelper(this.match(str)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 3),\n            start = _step$value[0],\n            end = _step$value[1],\n            tags = _step$value[2];\n          var _iterator2 = _createForOfIteratorHelper(tags),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var tag = _step2.value;\n              if (typeof actions[tag] === 'function') {\n                actions[tag](start, end, str.slice(start, end + 1));\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n  return StateMachine;\n}();\nmodule.exports = StateMachine;","map":{"version":3,"names":["INITIAL_STATE","FAIL_STATE","StateMachine","dfa","_classCallCheck","stateTable","accepting","tags","match","str","self","Symbol","iterator","_regeneratorRuntime","mark","_callee","state","startRun","lastAccepting","lastState","p","c","wrap","_callee$","_context","prev","next","length","stop","apply","actions","_iterator","_createForOfIteratorHelper","_step","_step$value","_slicedToArray","value","start","end","_iterator2","_step2","tag","slice"],"sources":["/home/jaona/myfiles/Jaona/Components/dashboard/node_modules/dfa/src/StateMachine.js"],"sourcesContent":["const INITIAL_STATE = 1;\nconst FAIL_STATE = 0;\n\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\nexport default class StateMachine {\n  constructor(dfa) {\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n  match(str) {\n    let self = this;\n    return {\n      *[Symbol.iterator]() {\n        let state = INITIAL_STATE;\n        let startRun = null;\n        let lastAccepting = null;\n        let lastState = null;\n\n        for (let p = 0; p < str.length; p++) {\n          let c = str[p];\n\n          lastState = state;\n          state = self.stateTable[state][c];\n\n          if (state === FAIL_STATE) {\n            // yield the last match if any\n            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n              yield [startRun, lastAccepting, self.tags[lastState]];\n            }\n\n            // reset the state as if we started over from the initial state\n            state = self.stateTable[INITIAL_STATE][c];\n            startRun = null;\n          }\n\n          // start a run if not in the failure state\n          if (state !== FAIL_STATE && startRun == null) {\n            startRun = p;\n          }\n\n          // if accepting, mark the potential match end\n          if (self.accepting[state]) {\n            lastAccepting = p;\n          }\n\n          // reset the state to the initial state if we get into the failure state\n          if (state === FAIL_STATE) {\n            state = INITIAL_STATE;\n          }\n        }\n\n        // yield the last match if any\n        if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n          yield [startRun, lastAccepting, self.tags[state]];\n        }\n      }\n    };\n  }\n\n  /**\n   * For each match over the input sequence, action functions matching\n   * the tag definitions in the input pattern are called with the startIndex,\n   * endIndex, and sub-match sequence.\n   */\n  apply(str, actions) {\n    for (let [start, end, tags] of this.match(str)) {\n      for (let tag of tags) {\n        if (typeof actions[tag] === 'function') {\n          actions[tag](start, end, str.slice(start, end + 1));\n        }\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;;;AAAA,IAAMA,aAAa,GAAG,CAAtB;AACA,IAAMC,UAAU,GAAG,CAAnB;;;;;IAMqBC,YAAN;EACb,SAAAA,aAAYC,GAAD,EAAM;IAAAC,eAAA,OAAAF,YAAA;SACVG,UAAL,GAAkBF,GAAG,CAACE,UAAtB;SACKC,SAAL,GAAiBH,GAAG,CAACG,SAArB;SACKC,IAAL,GAAYJ,GAAG,CAACI,IAAhB;;;;;;;;WAOF,SAAAC,MAAMC,GAAD,EAAM;UACLC,IAAI,GAAG,IAAX;iCAEIC,MAAM,CAACC,QAAT,eAAAC,mBAAA,GAAAC,IAAA,UAAAC,QAAA;QAAA,IAAAC,KAAA,EAAAC,QAAA,EAAAC,aAAA,EAAAC,SAAA,EAAAC,CAAA,EAAAC,CAAA;QAAA,OAAAR,mBAAA,GAAAS,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cACMV,KAAK,GAAGhB,aAAZ;cACIiB,QAAQ,GAAG,IAAf;cACIC,aAAa,GAAG,IAApB;cACIC,SAAS,GAAG,IAAhB;cAESC,CAAC,GAAG,CAAb;YAAA;cAAA,MAAgBA,CAAC,GAAGX,GAAG,CAACkB,MAAxB;gBAAAH,QAAA,CAAAE,IAAA;gBAAA;cAAA;cACML,CAAC,GAAGZ,GAAG,CAACW,CAAD,CAAX;cAEAD,SAAS,GAAGH,KAAZ;cACAA,KAAK,GAAGN,IAAI,CAACL,UAAL,CAAgBW,KAAhB,EAAuBK,CAAvB,CAAR;cAAA,MAEIL,KAAK,KAAKf,UAAd;gBAAAuB,QAAA,CAAAE,IAAA;gBAAA;cAAA;cAAA,MAEMT,QAAQ,IAAI,IAAZ,IAAoBC,aAAa,IAAI,IAArC,IAA6CA,aAAa,IAAID,QAAlE;gBAAAO,QAAA,CAAAE,IAAA;gBAAA;cAAA;cAAAF,QAAA,CAAAE,IAAA;qBACQ,CAACT,QAAD,EAAWC,aAAX,EAA0BR,IAAI,CAACH,IAAL,CAAUY,SAAV,CAA1B,CAAN;YAAA;cAHsB;;cAOxBH,KAAK,GAAGN,IAAI,CAACL,UAAL,CAAgBL,aAAhB,EAA+BqB,CAA/B,CAAR;cACAJ,QAAQ,GAAG,IAAX;YAAA;cAdiC;;kBAkB/BD,KAAK,KAAKf,UAAV,IAAwBgB,QAAQ,IAAI,IAAxC,EAA8C;gBAC5CA,QAAQ,GAAGG,CAAX;eAnBiC;;kBAuB/BV,IAAI,CAACJ,SAAL,CAAeU,KAAf,CAAJ,EAA2B;gBACzBE,aAAa,GAAGE,CAAhB;eAxBiC;;kBA4B/BJ,KAAK,KAAKf,UAAd,EAA0B;gBACxBe,KAAK,GAAGhB,aAAR;;;cA7B4BoB,CAAC,EAAjC;cAAAI,QAAA,CAAAE,IAAA;cAAA;YAAA;cAAA,MAkCIT,QAAQ,IAAI,IAAZ,IAAoBC,aAAa,IAAI,IAArC,IAA6CA,aAAa,IAAID,QAAlE;gBAAAO,QAAA,CAAAE,IAAA;gBAAA;cAAA;cAAAF,QAAA,CAAAE,IAAA;qBACQ,CAACT,QAAD,EAAWC,aAAX,EAA0BR,IAAI,CAACH,IAAL,CAAUS,KAAV,CAA1B,CAAN;YAAA;YAAA;cAAA,OAAAQ,QAAA,CAAAI,IAAA;UAAA;QAAA,GAAAb,OAAA;MAAA;;;;;;;;;WAWR,SAAAc,MAAMpB,GAAD,EAAMqB,OAAN,EAAe;MAAA,IAAAC,SAAA,GAAAC,0BAAA,CACa,KAAKxB,KAAL,CAAWC,GAAX,CAA/B;QAAAwB,KAAA;MAAA;4DAAgD;UAAA,IAAAC,WAAA,GAAAC,cAAA,CAAAF,KAAA,CAAAG,KAAA;YAAtCC,KAAD,GAAAH,WAAA;YAAQI,GAAR,GAAAJ,WAAA;YAAa3B,IAAb,GAAA2B,WAAA;UAAA,IAAAK,UAAA,GAAAP,0BAAA,CACSzB,IAAhB;YAAAiC,MAAA;UAAA;mEAAsB;cAAA,IAAbC,GAAT,GAAAD,MAAA,CAAAJ,KAAA;kBACM,OAAON,OAAO,CAACW,GAAD,CAAd,KAAwB,UAA5B,EAAwC;gBACtCX,OAAO,CAACW,GAAD,CAAP,CAAaJ,KAAb,EAAoBC,GAApB,EAAyB7B,GAAG,CAACiC,KAAJ,CAAUL,KAAV,EAAiBC,GAAG,GAAG,CAAvB,CAAzB"},"metadata":{},"sourceType":"script","externalDependencies":[]}